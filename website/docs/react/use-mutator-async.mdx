---
description: 'Hook for asynchronous mutations.'
sidebar_position: 5
---
# useMutatorAsync

```tsx
const state = useAppState();

const [isLoading, value] = useSnap(state, state => [state.isLoading, state.value]);

const loadWords = useMutatorAsync(state, async function* asyncFunction(state) {
    state.isLoading = true;
    const fetchedValue = await fetchSomething();
    yield; // starts the change recording process after any awaits 

    state.isLoading = false;
    state.value = fetchedValue;
});

useEffect(() => loadWords(), []);

return (
    <div>
        <div>isLoading: {isLoading}</div>
        <div>value: {value}</div>        
    </div>
);

```
To support asynchronous loading and to control change-recording and as well as re-rendering, you use an async generator function with a passed in state.  At the begining of your mutator, you may modify your state and the rendering will not occur until you either `await` something or your function exits.

When you `await` inside your function, change recording stops at that moment.  When the await returns you may do additional `await` calls, but you must call `yield` prior to modifying your state.  Calling yield will begin change recording, and will again allow for re-rendering.

This may seem a bit cumbersome, but it allows you to completely control how a series of multiple async `awaits` can occur without affecting state until all is completed or successful 

Again, there is an optional dependency list parameter as well in order to use props inside your mutator function.

*Warning:* The following applies to any asynchronous code, not just Diagon. Be careful when using async functions with mutation! You could have multiple async functions executing, or simply some synchronous function modify state while your async process under way!  It is much better to make an object that represents your async call with local state on it that is unique per async operation.  That way if it gets replaced or invalidated you can ignore everything but the latest operation.  


## Nested Async Generators

```tsx
const state = useAppState();

const [isLoading, value] = useSnap(state, state => [state.isLoading, state.value]);

async function* myFetcher(state: State) {
    
    const fetchedValue = await fetchSomething();
    yield; // must yield because we awaited.

    state.prop0 = fetchedValue;
}

const loadWords = useMutatorAsync(state, async function* asyncFunction(state) {
    state.isLoading = true;
    
    yield* myFetcher(state);    
    yield; //caveat: You must yield in the caller after the nested function returns

    state.isLoading = false;    
});

useEffect(() => loadWords(), []);

```